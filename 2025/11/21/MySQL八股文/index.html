<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL八股文 | JasonQian's Blog</title><meta name="author" content="JasonQian"><meta name="copyright" content="JasonQian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="存储引擎及架构 数据库的三大范式  第一范式：字段必须是原子性，不能再分 第二范式：每个非主属性必须完全依赖于主键，消除部分依赖 第三范式：非主键之间不能有依赖关系，消除传递依赖   关系型数据库区别  关系型数据库：复杂的数据结构归结为简单二维表格形式  MySQL、Oracle   非关系型数据库：将数据存储为键值对集合，其中键作为唯一标识符  Redis、MongoDB     内部架构及作">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL八股文">
<meta property="og:url" content="http://example.com/2025/11/21/MySQL%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="JasonQian&#39;s Blog">
<meta property="og:description" content="存储引擎及架构 数据库的三大范式  第一范式：字段必须是原子性，不能再分 第二范式：每个非主属性必须完全依赖于主键，消除部分依赖 第三范式：非主键之间不能有依赖关系，消除传递依赖   关系型数据库区别  关系型数据库：复杂的数据结构归结为简单二维表格形式  MySQL、Oracle   非关系型数据库：将数据存储为键值对集合，其中键作为唯一标识符  Redis、MongoDB     内部架构及作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.jasonqian.com/img/menhera_7.jpg">
<meta property="article:published_time" content="2025-11-20T22:08:16.000Z">
<meta property="article:modified_time" content="2025-12-01T19:21:46.000Z">
<meta property="article:author" content="JasonQian">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.jasonqian.com/img/menhera_7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL八股文",
  "url": "http://example.com/2025/11/21/MySQL%E5%85%AB%E8%82%A1%E6%96%87/",
  "image": "https://www.jasonqian.com/img/menhera_7.jpg",
  "datePublished": "2025-11-20T22:08:16.000Z",
  "dateModified": "2025-12-01T19:21:46.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "JasonQian",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/11/21/MySQL%E5%85%AB%E8%82%A1%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL八股文',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<link rel="stylesheet" href="/css/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg" style="background-image: url(https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202411281151046.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://www.jasonqian.com/img/menhera_1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://www.jasonqian.com/img/menhera_7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">JasonQian's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL八股文</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-20T22:08:16.000Z" title="发表于 2025-11-21 06:08:16">2025-11-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-01T19:21:46.000Z" title="更新于 2025-12-02 03:21:46">2025-12-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="存储引擎及架构">存储引擎及架构</h2>
<h3 id="数据库的三大范式"><strong>数据库的三大范式</strong></h3>
<ol>
<li>第一范式：字段必须是<strong>原子性，不能再分</strong></li>
<li>第二范式：每个非主属性必须完全依赖于主键，<strong>消除部分依赖</strong></li>
<li>第三范式：非主键之间不能有依赖关系，<strong>消除传递依赖</strong></li>
</ol>
<hr>
<h3 id="关系型数据库区别">关系型数据库区别</h3>
<ol>
<li>关系型数据库：复杂的数据结构归结为简单<strong>二维表格</strong>形式
<ul>
<li>MySQL、Oracle</li>
</ul>
</li>
<li>非关系型数据库：将数据存储为<strong>键值对集合</strong>，其中键作为唯一标识符
<ul>
<li>Redis、MongoDB</li>
</ul>
</li>
</ol>
<hr>
<h3 id="内部架构及作用">内部架构及作用</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211015116.png" alt="image-20251121101513870"></p>
<ol>
<li><strong>连接器</strong>：不同语言与数据库进行交互，如java，php</li>
<li><strong>系统管理和控制工具</strong>：涵盖：运维监控、数据维护、性能优化、安全管控四大核心场景</li>
<li><strong>连接层</strong></li>
</ol>
<p>连接时会优先加载全局权限和数据库级权限</p>
<p>连接过程是一个TCP长连接，MySQL服务器和客户端通讯是“半双工”，只能单方面发送请求，不能同时发送</p>
<p>TCP长连接带来的问题 ：占用内存，内存涨的特别快；如何解决？</p>
<ul>
<li>定期断开长连接</li>
<li>使用Druid会定期检测空闲连接，超过设定时间的连接会被释放</li>
</ul>
<ol start="4">
<li><strong>SQL接口</strong>：接收用户的SQL命令，并返回用户查询的结果</li>
<li><strong>解析器</strong></li>
</ol>
<p>在执行语句之前，会解析查询的语言，在过程中会判断语法，将查询字段、表、条件封装到内部的数据结构形成解析树</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211017830.png" alt="image-20251121101745611"></p>
<ol start="6">
<li><strong>查询缓存</strong></li>
</ol>
<p>MySQL8将这块删除了，因为缓存匹配条件严格，需要SQL完全一致</p>
<ol start="7">
<li><strong>查询优化器</strong></li>
</ol>
<p>通过语法解析，MySQL知道真实意图了，但是写的SQL语句不够高效，MySQL会给语句做优化，比如使用了哪个索引？最左匹配原则？</p>
<ol start="8">
<li><strong>执行</strong>：判断是否有权限才可以接着执行</li>
<li><strong>存储引擎接口</strong></li>
<li><strong>文件系统层</strong></li>
</ol>
<hr>
<h3 id="一条SQL请求的过程">一条SQL请求的过程</h3>
<ol>
<li>SQL客户端与服务器建立连接，该请求发送到连接器</li>
<li>通过MySQL关键字将语法解析成一个内部解析树，再判断有没有错误语法</li>
<li>如果命中缓存，直接返回结果</li>
<li>基于成本优化SQL语句</li>
<li>调用存储引擎接口执行</li>
</ol>
<hr>
<h3 id="主流的存储引擎">主流的存储引擎</h3>
<ol>
<li><strong>InnoDB（默认）</strong>
<ul>
<li>支持事务处理，具备ACID特性（原子性、一致性、隔离性、持久性）</li>
<li>采用行级锁，高并发下减少锁冲突</li>
<li>支持外键约数，便于维护表之间关系</li>
</ul>
</li>
<li><strong>MyISAM</strong>
<ul>
<li>读取速度快</li>
<li>不支持事务和行级锁</li>
</ul>
</li>
<li><strong>Memory</strong>
<ul>
<li>数据存储在内存中</li>
<li>支持哈希索引</li>
</ul>
</li>
</ol>
<hr>
<h3 id="一条查询语句的关键字执行顺序">一条查询语句的关键字执行顺序</h3>
<p>逻辑执行顺序：</p>
<p><strong>FROM</strong></p>
<p><strong>ON</strong></p>
<p><strong>JOIN</strong></p>
<p><strong>WHERE</strong></p>
<p><strong>GROUP BY</strong></p>
<p><strong>HAVING</strong></p>
<p><strong>SELECT</strong></p>
<p><strong>DISTINCT</strong></p>
<p><strong>ORDER BY</strong></p>
<p><strong>LIMIT / OFFSET</strong></p>
<p>【<strong>例子</strong>】</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211024256.png" alt="image-20251121102422090"></p>
<ol>
<li>FROM：拿到emp、dept两张表的原始行</li>
<li>ON：按照 <a target="_blank" rel="noopener" href="http://d.id">d.id</a> = e.dept_id 先做匹配</li>
<li>JOIN：把匹配成功的行拼在一起</li>
<li>WHERE：丢掉 salary &lt;= 10000 的行</li>
<li>GROUP BY：按照 <a target="_blank" rel="noopener" href="http://d.name">d.name</a> 分组</li>
<li>HAVING：保留组内数据 ≥ 3 的组</li>
<li>SELECT：算出 dept 别名、cnt 聚合列</li>
<li>ORDER BY：按 cnt 排序</li>
<li>LIMIT：取前 5 行</li>
</ol>
<hr>
<h3 id="InnoDB的三大特性">InnoDB的三大特性</h3>
<ol>
<li>“<strong>外在能力</strong>”
<ul>
<li>事务（ACID）</li>
<li>行级锁</li>
<li>MVCC</li>
</ul>
</li>
<li><strong>“内部机制” / 核心优化特性、机制</strong></li>
</ol>
<ul>
<li><strong>插入缓存</strong></li>
</ul>
<p>往二级索引里插一条记录，目标<strong>叶子页</strong>如果不在内存中，需要将<strong>那一页随机读进来，修改，再写回去</strong>，很慢</p>
<p><strong>InnoDB优化</strong>：<strong>先不读那页</strong>，将要插入的数据、插到哪一页，<strong>写到另一个 B+ 树里</strong>（这棵树叫 Change Buffer），等以后那一页<strong>正好进内存或者后台空闲</strong>，再写入数据</p>
<blockquote>
<p><strong>叶子页</strong>：</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211030439.png" alt="image-20251121103021360"></p>
<p>想要插入0036这条数据，就需要将 【0035, 0065, 0088】这个叶子页的数据全部拿出来</p>
</blockquote>
<ul>
<li><strong>双写</strong></li>
</ul>
<p>页（Page）写入磁盘分为两步：先写到共享双写区；再落目标数据文件</p>
<p>目的：发生意外情况，可以从副本恢复这页数据</p>
<ul>
<li><strong>自适应哈希索引</strong></li>
</ul>
<p>热点范围自动创建哈希加速等值查找，省去多层B+树跳转</p>
<hr>
<h2 id="锁-2">锁</h2>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211032298.png" alt="image-20251121103231205"></p>
<h3 id="大致介绍">大致介绍</h3>
<ol>
<li><strong>兼容性</strong></li>
</ol>
<p>共享锁：共享锁之间是兼容的，共享锁和排他锁是互斥的</p>
<p>排他锁：排他锁和任何锁都是不兼容的</p>
<ol start="2">
<li><strong>粒度</strong></li>
</ol>
<p>全局锁：锁住数据库中的所有表，即锁住库</p>
<p>表级锁：每次操作要锁住整张表，锁定粒度大，发生锁冲突概率最高</p>
<ul>
<li>表锁</li>
<li>元数据锁</li>
<li>意向锁</li>
</ul>
<p>行级锁：每次操作要锁住对应的行，发生锁冲突概率最低</p>
<ul>
<li>行锁（记录锁）</li>
<li>间隙锁</li>
<li>临建锁</li>
</ul>
<hr>
<h3 id="全局锁">全局锁</h3>
<p>加锁后整个实例处于只读状态，后续的所有DML、DDL都会被阻塞，但可以执行DQL语句</p>
<p>使用场景：用于从数据库备份数据，获得一致性的数据</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211035412.png" alt="image-20251121103519448"></p>
<p>全局锁特点：</p>
<ol>
<li>如果在主库上备份，备份期间不能执行更新，业务被暂停</li>
<li>如果在从库上备份，备份期间不能执行主库同步的二进制文件（binlog），导致从数据延迟</li>
<li>【解决方式】使用快照读备份，不加全局锁</li>
</ol>
<hr>
<h3 id="表级锁">表级锁</h3>
<ol>
<li><strong>表锁</strong></li>
</ol>
<ul>
<li>表共享读锁（read lock，读锁，S锁）：读锁不会阻塞其他客户端的读，但是会阻塞写</li>
<li>表独占写锁（write lock，写锁，X锁）：写锁会阻塞其他客户端的读和写</li>
</ul>
<ol start="2">
<li><strong>元数据锁</strong>：元数据锁会在执行增删改的时候自动加上，事务提交后会被自动释放</li>
<li><strong>意向锁</strong></li>
</ol>
<p>想上<strong>表级别读锁</strong>，首先需要确保没有<strong>行级别写锁</strong>，如果有，需要等到行级别写锁释放。<br>
想上<strong>表级别写锁</strong>，首先需要确保没有<strong>行级别读锁</strong>和<strong>行级别写锁</strong>，如果有，需要等到行级别读锁和行级别写锁释放。</p>
<p>怎么快速知道有没有行级锁，就需要用到意向锁</p>
<ul>
<li>意向共享锁（<strong>IS锁</strong>）锁粒度：表级锁，当事务准备在某条记录上<strong>加行级读锁</strong>时，需要先在<strong>表级别加一个意向共享锁</strong></li>
<li>意向排他锁（<strong>IX锁</strong>）锁粒度：表级锁，当事务准备在某条记录上<strong>加行级写锁</strong>时，需要先在<strong>表级别加一个意向排他锁</strong></li>
</ul>
<p>如果没有意向锁，系统每次想加表锁，都得翻遍整张表看有没有行锁，效率低下</p>
<p>有了意向锁，只需要查看是否存在**意向共享锁（IS锁）、意向排他锁（IX锁）**即可</p>
<p>执行查询语句时，避免行锁和表锁的冲突，不用检查每行数据</p>
<hr>
<h3 id="行级锁">行级锁</h3>
<ol>
<li><strong>行锁（记录锁）</strong></li>
</ol>
<p>锁定单个行记录的锁，针对索引加锁，防止其他事务进行update和delete操作</p>
<p>InnoDB有两种类型行锁</p>
<ul>
<li>共享锁（S-share）：允许多个事务去读一行，用于并发读取</li>
<li>排他锁（X-exclude）：加锁后只允许当前事务进行 读/写 操作，其他事务不能进行 读/写操作</li>
</ul>
<ol start="2">
<li><strong>间隙锁</strong></li>
</ol>
<p>锁“空隙”，不锁行本身，用来阻止别人往这个空隙里插入新行，从而避免幻读或违反唯一性</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211043397.png" alt="image-20251121104307380"></p>
<ol start="3">
<li><strong>临键锁</strong></li>
</ol>
<p>左开右闭 ( ]</p>
<p><strong>记录锁</strong> (Record Lock) ＋ <strong>右侧间隙锁</strong> (Gap Lock)<br>
既把命中的那一行锁住，又把它<strong>右边那段空档</strong>一并锁上，防止别人插队产生幻读</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211043884.png" alt="image-20251121104356835"></p>
<ol start="4">
<li><strong>区别</strong></li>
</ol>
<p>假设有 id 为 <strong>{1，3，6，7，9}</strong> 这五个数据</p>
<ul>
<li>行锁：<strong>命中存在值</strong>，查询id = 6的数据；锁住 <strong>id = 6</strong></li>
<li>间隙锁：<strong>命中不存在值</strong>，查询 id = 5 的数据；锁住 <strong>id 在 (3, 6) 之间</strong>的数据，防止插入5</li>
<li>临键锁：<strong>查询范围触及6</strong>，查询 id &gt;= 6 的数据；锁住 <strong>id 在 (3, 6]、(6, 7]、(7, 9]</strong> 数据；右边 ] 都是真实数据</li>
</ul>
<p>查询 id &gt; 5 and id &lt; 8 的数据</p>
<p><strong>1 3 【 6 7 】 9</strong></p>
<ul>
<li>行锁：锁住 id = 6, id = 7</li>
<li>临键锁：锁住 (3, 6]、(6, 7]</li>
<li>间隙锁：锁住右侧边界间隙 (7, 9)</li>
</ul>
<hr>
<h3 id="死锁的检测及处理策略">死锁的检测及处理策略</h3>
<ol>
<li><strong>检测</strong>：MySQL使用<strong>等待图</strong>（Wait-for Graph）算法来检测死锁，通过检查事务之间的依赖关系来判断是否存在死锁，MySQL自带的死锁检测</li>
</ol>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211048018.png" alt="image-20251121104848996"></p>
<ol start="2">
<li><strong>死锁处理的策略</strong></li>
</ol>
<ul>
<li>回滚事务：发现死锁后，可以回滚其中资源持有最少得一个，解除死锁</li>
<li>返回错误信息</li>
<li>超时设置和重试机制</li>
</ul>
<ol start="3">
<li><strong>死锁的预防和避免</strong></li>
</ol>
<ul>
<li>尽早提交事务：避免在事务中执行长时间计算、减少锁持有的时间</li>
<li>拆分大事务：减少事务持有锁的时间</li>
<li>使用合适的索引：减少锁定的数据量，提高查询效率</li>
<li>优化查询语句：使用精确条件限制查询范围，避免长时间持有锁定的行</li>
<li>使用乐观锁：通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出；如果当前版本号 &gt; 读取的版本号，认为更新成功，顺带将版本号 + 1</li>
</ul>
<hr>
<h2 id="索引">索引</h2>
<h3 id="什么是索引？">什么是索引？</h3>
<p>索引就像数据库里的加速目录，相当于告诉你“第123页是第5章”，记录了【<strong>关键值 ——&gt; 数据物理位置</strong>】映射，查询时不需要将整本书翻一遍</p>
<h3 id="个人理解的索引相关知识">个人理解的索引相关知识</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211102585.png" alt="image-20251121110254417"></p>
<p><strong>每一个索引对应一颗独立的B+树</strong></p>
<p>对于<strong>主键索引</strong>，它的叶子节点存的是整行数据</p>
<p>对于<strong>二级索引</strong>（普通索引/唯一索引），它的叶子节点存的是<strong>索引列数据</strong> 和 <strong>主键值</strong>（PK值），根据这个主键值<strong>回主键索引</strong>查找数据</p>
<p>如果有二级索引，没有主键索引怎么办？</p>
<ul>
<li><strong>InnoDB中必须有一个聚簇索引</strong></li>
<li>如果有主键索引，那么<strong>聚簇索引就是主键索引</strong></li>
<li>如果没有主键索引，但有一个NOT NULL 且 UNIQUE 的索引，<strong>聚簇索引就用它</strong></li>
<li>如果都没有，InnoDB会<strong>生成一个隐藏</strong>的6字节row_id，作为<strong>聚簇索引的key</strong></li>
</ul>
<h3 id="为什么要有索引？"><strong>为什么要有索引？</strong></h3>
<ol>
<li>极速查找</li>
<li>减少IO</li>
<li>约数 &amp; 唯一性 ：比如保证邮箱不重复</li>
<li>支持排序和分组：B+树天生按键排序</li>
</ol>
<h3 id="索引类型">索引类型</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211105071.png" alt="image-20251121110539051"></p>
<h3 id="Hash索引">Hash索引</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211106207.png" alt="image-20251121110600151"></p>
<p>hash索引存储了索引字段的hash值和数据所在磁盘文件指针，如果来了一句sql：</p>
<p>select * from tab where id= 1 那么mysql会怎么去执行这条sql语句：<br>
a、将id = 1 做一次hash运算得到hash为123<br>
b、拿到hash为123在hash索引中去找123的节点<br>
c、节点所对应的数据就是数据内容所在磁盘文件的指针<br>
d、通过一次磁盘I/O得到所有的内容，即id=1，name=张三。<br>
e、最后返回结果。</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>不存储字段值</li>
<li>无法进行排序</li>
<li>不支持部分索引列匹配查找</li>
<li>不支持任何范围查询</li>
</ul>
<h3 id="B树索引特点">B树索引特点</h3>
<p>B树叫做多路平衡查找树，多路就是说一个结点下面可以有多个子节点。</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211107718.png" alt="image-20251121110732653"></p>
<h3 id="B-树索引特点">B+树索引特点</h3>
<p>B+树就是B树的一种变种，非叶子节点存放索引，叶子节点存放数据</p>
<p>B+树叶子节点使用的是<strong>双向链表</strong></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211108037.png" alt="image-20251121110801244"></p>
<h3 id="B树和B-树的区别">B树和B+树的区别</h3>
<ol>
<li>B树的所有节点即存放键（key），也存放值（value）；B+树只有叶子结点存放key和value，非叶子结点只存放key</li>
<li>B树的叶子节点是独立的；B+树的叶子节点有一条链表指向相邻叶子节点。</li>
<li>B树的检索过程不稳定，可能还没有到达叶子节点，检索就结束了。但是B+树每次检索数据都要检索到叶子节点，查找比较稳定。</li>
<li>B+树的范围查询只需要对链表进行遍历即可。</li>
</ol>
<h3 id="为什么用B-树而不是红黑树？">为什么用B+树而不是红黑树？</h3>
<ol>
<li><strong>树高</strong></li>
</ol>
<p>红黑树是一种特殊的平衡树，想要覆盖大量键，树高很容易升高，在磁盘上就多一层随机I/O</p>
<p>B+ 树每层能存放几百上千指针，树高很小，随机 I/O 很低</p>
<ol start="2">
<li><strong>单位</strong></li>
</ol>
<p>红黑树的单位是一个对象，想要获取连续的数据，需要随机读</p>
<p>B+ 树的单位是页，一次读取一个节点，就等于读取这一页的数据</p>
<ol start="3">
<li><strong>范围查询</strong></li>
</ol>
<p>红黑树的范围查询需要不断的进行中序遍历，耗时</p>
<p>B+ 树叶子节点之间有双向链表，对于范围查询很有帮助</p>
<ol start="4">
<li><strong>维护成本</strong></li>
</ol>
<p>红黑树每次插入/删除都可能触发旋转和颜色翻转</p>
<p>B+树的插入/删除是以页为单位进行的，能够批量移动</p>
<h3 id="索引的分类"><strong>索引的分类</strong></h3>
<ol>
<li><strong>按照逻辑作用</strong></li>
</ol>
<p>主键索引、唯一索引、普通索引、联合索引、全文索引</p>
<ol start="2">
<li><strong>数据结构/算法</strong></li>
</ol>
<p>空间索引、B+树、Hash索引</p>
<ol start="3">
<li><strong>物理索引</strong></li>
</ol>
<p>聚簇索引、非聚簇索引、覆盖索引</p>
<h3 id="为什么B-树三层能存储2000万数据？"><strong>为什么B+树三层能存储2000万数据？</strong></h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211411513.png" alt="po_diagram (1)"></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211411882.png" alt="po_diagram (2)"></p>
<h3 id="Innodb-MyISAM在存储结构的区别？">Innodb&amp;MyISAM在存储结构的区别？</h3>
<p>Innodb—聚簇索引：叶子结点包含了完整的数据记录</p>
<p>MyISAM—非聚簇索引：叶子节点存的是<strong>主键值</strong>，通过主键值去聚簇索引找到完整数据</p>
<h3 id="索引分类">索引分类</h3>
<ol>
<li><strong>主键索引</strong></li>
</ol>
<p>每个表只能有一个主键索引</p>
<p><strong>特性</strong></p>
<ul>
<li>强制唯一性约束，不允许NULL值</li>
<li>是表的主标识符</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>作为表的行标识符</li>
<li>需要快速通过主键值检索单行数据</li>
<li>建立表与表之间的关系</li>
</ul>
<hr>
<ol start="2">
<li><strong>唯一索引</strong></li>
</ol>
<p>确保索引<strong>列或列组合</strong>的值唯一的索引</p>
<p><strong>特性</strong></p>
<ul>
<li>允许NULL值（通常只能有一个NULL值）</li>
<li>可以创建在多个列上</li>
<li>不同于主键索引，一个表可以有多个唯一索引</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>
<p>需要确保业务数据唯一性的列（身份证、邮箱等）</p>
</li>
<li>
<p>代替主键索引</p>
</li>
</ul>
<hr>
<ol start="3">
<li><strong>普通索引</strong></li>
</ol>
<p>最基本的索引类型，没有唯一性约束</p>
<p><strong>特性</strong></p>
<ul>
<li>仅用于加速查询，不强制数据唯一性</li>
<li>可以包含NULL值</li>
<li>创建和维护成本相对较低</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>常用于WHERE条件、JOIN条件和ORDER BY子句中的列</li>
<li>查询频繁但不需要唯一约束的列</li>
</ul>
<hr>
<ol start="4">
<li><strong>联合索引</strong></li>
</ol>
<p>建立在多个列上的索引，也称为复合索引，其本质是一个二级索引</p>
<p><strong>特性</strong></p>
<ul>
<li>索引顺序很重要（遵循最左前缀原则）</li>
</ul>
<blockquote>
<p>“<strong>最左前缀原则</strong>”（Leftmost Prefix Rule）指的是：</p>
<p>当你为表建立了<strong>联合索引</strong>（例如 INDEX (a, b, c)），MySQL 在检索、排序、分组时，<strong>只能从最左边开始，连续地</strong>利用索引里的列。也就是它能用上 a，或 a,b，或 a,b,c，但<strong>跳过中间某列就不行</strong>。</p>
</blockquote>
<ul>
<li>可以是唯一索引或普通索引</li>
<li>比单列索引能覆盖更复杂的查询条件</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>多列组合查询频繁的情况</li>
<li>需要覆盖索引优化查询性能时</li>
<li>示例：INDEX idx_name_age (name, age)</li>
</ul>
<hr>
<ol start="5">
<li><strong>全文索引</strong></li>
</ol>
<p>通过关键字的匹配来进行查询过滤,就是全文索引</p>
<p>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</p>
<p>和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字</p>
<p>应用场景</p>
<ul>
<li>文本内容的模糊匹配和关键词搜索</li>
<li>替代效率低的LIKE '%keyword%'查询</li>
<li>搜索引擎类应用</li>
</ul>
<hr>
<h3 id="索引的利弊">索引的利弊</h3>
<p><strong>优点</strong></p>
<ol>
<li>保证建立索引的列唯一性，生成唯一的rowId</li>
<li>有效缩短数据的检索时间</li>
<li>加快表与表之间的连接</li>
<li>加快分组和排序顺序</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>创建、维护时间成本大</li>
<li>空间成本大</li>
<li>影响增删改的效率</li>
</ol>
<p><strong>什么情况下需要建立索引？</strong></p>
<ol>
<li>数据量大</li>
<li>需要排序的字段</li>
<li>表与表连接用于多表查询的约束条件建立索引</li>
</ol>
<hr>
<h3 id="回表查询、索引覆盖、索引下推、索引跳跃">回表查询、索引覆盖、索引下推、索引跳跃</h3>
<ol>
<li>回表查询</li>
</ol>
<p>假设执行 select name, age from user where name=‘X’;<br>
<strong>通过where name=‘X’ 看有没有对应的name索引，或者包含name的索引</strong><br>
找到二级索引 idx_name(name)<br>
但它的叶子页只保存 name + 主键 PK，不包含 age。<br>
于是优化器用 idx_name 找到主键，再回到<strong>聚簇索引页</strong>取出整行获取 age</p>
<p><strong>说白了：查询的字段，二级索引没有包含</strong></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211238759.png" alt="image-20251121123727501"></p>
<ol start="2">
<li><strong>索引覆盖</strong></li>
</ol>
<p>想要查询通过name查询age，由于二级索引idx_name_age包含了name，通过name定位到叶子结点，查询的age字段索引也包含，直接将结果返回</p>
<p><strong>说白了：你要根据条件查找的列，索引里全都有，于是直接在索引里把结果拿走，不用再回到主键树里取整行数据</strong></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211238003.png" alt="image-20251121123751141"></p>
<ol start="3">
<li><strong>索引下推</strong></li>
</ol>
<p><strong>说白了：在索引的时候，在索引里判断把不合格的记录排除，再去回表拿剩下的少数几行。这样回表次数大幅减少，查询更快。</strong></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211238411.png" alt="image-20251121123814756"></p>
<ol start="4">
<li><strong>索引跳跃</strong></li>
</ol>
<p>若复合索引为 (age, gender)，而查询只给了 gender = ‘m’ 没有 age 条件，<br>
优化器就会启用 索引跳跃 (Skip Scan)：<br>
先枚举可能的 age 值（例如 18、20），<br>
分别在 (age, *) 区间内利用 gender = ‘m’ 做范围查找，<br>
从而避免全表扫描。</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211238720.png" alt="image-20251121123832998"></p>
<p><strong>复合索引 (A, B) 下，只给了 B 的条件时，优化器会按 A 的每个不同取值 逐个做 小范围扫描（A=某值 AND B 满足条件），再把结果合并，这样可以避免全表扫描</strong></p>
<blockquote>
<p>**【问题】**查询age = 11，不是已经满足索引覆盖的条件了吗？age在复合索引(gender, age)中了</p>
<p><strong>【答】：因为没有满足最左侧条件</strong></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211241170.png" alt="image-20251121124103365"></p>
</blockquote>
<hr>
<h3 id="索引失效的场景">索引失效的场景</h3>
<ol>
<li><strong>不满足最左匹配原则</strong></li>
<li>使用了SELECT *</li>
<li><strong>索引列参与运算</strong></li>
<li><strong>索引列使用了函数</strong></li>
<li><strong>使用了错误的LIKE语句</strong></li>
<li>类型隐式转换</li>
<li><strong>使用OR且OR左右其中一列没有索引</strong></li>
<li>不等于比较</li>
<li>ORDER BY导致索引失效</li>
</ol>
<hr>
<h3 id="索引越多越好吗？"><strong>索引越多越好吗？</strong></h3>
<ol>
<li>每次增删改操作都要维护所有相关索引结构（更新B+树），写入时间上升</li>
<li>空间占用大</li>
</ol>
<hr>
<h2 id="日志">日志</h2>
<h3 id="执行一条-update-语句，期间发生了什么？">执行一条 update 语句，期间发生了什么？</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211243391.png" alt="image-20251121124335208"></p>
<h3 id="undo-log">undo log</h3>
<p><strong>undo log 记录的是数据修改前的状态，例如</strong></p>
<ul>
<li>执行 UPDATE 语句时，undo log会记录修改之前的数据</li>
<li>执行 DELETE 语句时，undo log 会记录被删除行的完整数据（以便回滚时恢复）</li>
<li>执行 INSERT 时，undo log 会记录插入的行信息（回滚时直接删除这行）</li>
</ul>
<h4 id="应用场景-3"><strong>应用场景</strong></h4>
<ol>
<li><strong>回滚事务</strong>：当事务需要被回滚时，通过Undo Log可以恢复到事务开始前的数据状态。</li>
<li><strong>MVCC（多版本并发控制）</strong>：InnoDB利用Undo Log来提供<strong>不同事务之间的一致性读视图</strong>，使得事务可以看到其他事务未提交之前的旧版本数据，从而避免锁竞争，提高并发性能。</li>
</ol>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211245356.png" alt="image-20251121124520502"></p>
<h4 id="undo-log版本链">undo log版本链</h4>
<p>我们每条数据其实都有两个隐藏字段，一个是trx_id，一个是roll_pointer</p>
<ul>
<li>trx_id：当前更新这条数据的事务ID</li>
<li>roll_pointer指向上一个版本的指针</li>
</ul>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211246870.png" alt="image-20251121124613676"></p>
<p>事务A id为50进行操作</p>
<p>事务B id为58进行操作</p>
<p>事务C id为69进行操作</p>
<h3 id="redo-log">redo log</h3>
<p>Redo Log记录的是对<strong>数据库页的物理修改操作</strong>，即每次事务对数据页进行更改后，都会将变更以“redo record”的形式写入Redo Log。</p>
<h4 id="应用场景-4"><strong>应用场景</strong></h4>
<ul>
<li><strong>数据库崩溃恢复</strong>：当系统发生异常重启或宕机时，通过重放Redo Log，能够确保已提交事务的修改不会丢失，保证了事务的持久性。</li>
<li><strong>避免频繁刷盘</strong>：InnoDB采用WAL（Write-Ahead Logging）策略，先写日志再修改磁盘数据，这样可以在一定程度上减少磁盘I/O，提升写入性能。</li>
</ul>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211248088.png" alt="image-20251121124825110"></p>
<h4 id="buffer-pool">buffer pool</h4>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211248999.png" alt="image-20251121124845909"></p>
<h4 id="redo-log刷盘时机">redo log刷盘时机</h4>
<p>Redo log刷盘策略，<code>innodb_flush_log_at_trx_commit</code>，取值（0/1/2）</p>
<ul>
<li>0：每隔一秒把log buffer刷到文件系统中</li>
<li>1：每次事务提交的时候，都把log buffer刷到文件系统中，立即刷新到磁盘上去</li>
<li>2：每次事务提交的时候，都把log buffer刷到系统文件中，但不会立即写入磁盘</li>
</ul>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211250812.png" alt="image-20251121125024743"></p>
<h4 id="日志文件组">日志文件组</h4>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211251664.png" alt="image-20251121125114385"></p>
<p>在这个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p>
<ul>
<li>write pos 是当前记录的位置，一边写一边后移</li>
<li>checkpoint 是当前要擦除的位置，也是往后推移，检查点的推进依赖于脏页被成功刷新到磁盘的数据页上</li>
</ul>
<p>当日志环将满时，InnoDB 会把<strong>最早那批未落盘的脏页</strong>刷进表空间文件，使 checkpoint 前移、Redo 日志重新腾出空间，再继续写后面的改动</p>
<h4 id="两阶段提交"><strong>两阶段提交</strong></h4>
<p>MySQL 为了避免出现redo log和bin log之间的逻辑不一致的问题，使用了「两阶段提交」来解决</p>
<p>两阶段提交是将单个事务的提交拆分成了2个阶段，【准备阶段】、【提交阶段】</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211252659.png" alt="image-20251121125257258"></p>
<ul>
<li>【<strong>prepare阶段</strong>】：将XID（内部XA事务的ID）写入redo log中<br>
同时将redo log对应的事务状态设置为prepare<br>
将redo log持久化到磁盘</li>
<li>【<strong>commit阶段</strong>】：把XID写入binlog，然后将binlog持久化到磁盘，<br>
调用引擎的提交事务接口，将redo log状态设置为commit</li>
</ul>
<hr>
<p><strong>在两阶段提交的不同时刻，MySQL 异常重启会出现什么现象？</strong></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211253288.png" alt="image-20251121125358234"></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211254174.png" alt="image-20251121125413731"></p>
<h4 id="redo-log思考">redo log思考</h4>
<blockquote>
<p>只要每次把修改后的数据页直接刷盘不就好了，还有 redo log 什么事？</p>
<p>【<strong>答</strong>】因为数据页大小为16KB，刷盘比较耗时间，如果写redo log，一行记录可能就占几十Byte，刷盘速度很快</p>
</blockquote>
<h3 id="bin-log">bin log</h3>
<p>bin log 记录的是数据库的<strong>逻辑修改事件</strong>（可以是 SQL 语句，也可以是行级别的修改记录，取决于格式），且只记录<strong>已提交的事务</strong></p>
<h4 id="作用">作用</h4>
<ul>
<li>主从复制：主库把自己的 Binlog 推送给从库，从库按顺序 replay，保证数据一致</li>
<li>数据恢复：通过重放 Binlog 恢复数据到某个时间点或事务状态</li>
</ul>
<hr>
<h4 id="三种格式">三种格式</h4>
<ol>
<li>Statement
<ul>
<li>记录每一条SQL语句</li>
<li>优点：日志量小</li>
<li>缺点：对于非等幂操作（NOW(), UUID()）可能导致数据不一致</li>
</ul>
</li>
<li>Row
<ul>
<li>记录每一行数据的变化</li>
<li>更加精确，可避免语句级问题</li>
<li>缺点：日志量大</li>
</ul>
</li>
<li>Mixed
<ul>
<li>混合模式，看实际操作选择Statement、Row</li>
</ul>
</li>
</ol>
<hr>
<h4 id="bin-log刷盘时机">bin log刷盘时机</h4>
<p>对于 InnoDB 存储引擎而言，只有在事务提交时才会记录bin log ，此时记录还在内存中，那么 bin log是什么时候刷到磁盘中的呢？</p>
<p>bin log刷盘策略，<code>sync_binlog</code>，取值（0/1/N）</p>
<ul>
<li>0：依赖操作系统定期同步，性能最佳，但崩溃时可能丢失多个事务</li>
<li>1：每次事务提交后同步，确保崩溃时最多丢失一个事务，安全性最高，但性能耗损最大</li>
<li>N：每提交N个事务后同步一次，平衡性能和数据安全</li>
</ul>
<hr>
<h4 id="中继日志">中继日志</h4>
<p>用于暂存从主库（Master）接收到的二进制日志事件，然后在本地执行的中间存储，确保数据同步的可靠性和持久性</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211259615.png" alt="image-20251121125948423"></p>
<hr>
<h4 id="慢查询日志">慢查询日志</h4>
<p>开启慢查询日志后，设定<code>long_query_time</code>，只要超过这个时间的SQL语句就会被记录下来</p>
<hr>
<h2 id="事务">事务</h2>
<p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p>
<h3 id="事务的开启方式">事务的开启方式</h3>
<ol>
<li>隐式事务：事务自动开启、提交、回滚，比如使用insert、update等语句</li>
<li>显式事务：需要手动开启、提交、回滚。命令BEGIN，COMMIT，ROLLBACK</li>
</ol>
<h3 id="事务ACID属性">事务ACID属性</h3>
<ol>
<li><strong>原子性</strong>（Atomicity）：事务是最小执行单位，要么全部完成，要么全部失败，【<strong>由undo log日志来实现</strong>】</li>
<li><strong>一致性</strong>（Consistency）：执行事务前后，数据保持一致，【<strong>由另外三个特性维持</strong>】</li>
<li><strong>隔离性</strong>（Isolation）：并发访问数据库时，事务不会被其他事务干扰【<strong>锁和MVCC机制来实现</strong>】</li>
<li><strong>持久性</strong>（Duration）：事务提交后，对数据库中数据改变时持久的【<strong>redo log日志来实现</strong>】</li>
</ol>
<hr>
<h3 id="并发事务处理带来的问题">并发事务处理带来的问题</h3>
<ol>
<li>脏读：一个事务读取了另一个事务未提交的数据</li>
<li>不可重复读：一个事务内，前后读取的数据不一致。（修改）</li>
<li>在一个事务中，相同查询条件，返回发结果集的数量不一致（新增）</li>
</ol>
<p>InnoDB 通过 临键锁 在<strong>当前读/写</strong>下避免RR ，而<strong>普通快照读</strong>在 RR 下就看不到新插入。</p>
<hr>
<h3 id="隔离级别">隔离级别</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211400748.png" alt="image-20251121140026797"></p>
<ol>
<li><strong>读未提交</strong>：直接绕过Read View</li>
<li><strong>读已提交</strong>：每一条查询操作都会创建一次Read View</li>
</ol>
<p>RC只有记录锁（行锁）</p>
<ol start="3">
<li><strong>可重复读</strong>：第一次查询操作的时候创建一次Read View</li>
</ol>
<p>RR有临键锁（记录锁+间隙锁）</p>
<ol start="4">
<li><strong>串行化</strong>：在可重复读的情况下，将Select 语句替换为 Select … lock in share mode，同时也会给读到的区间加锁</li>
</ol>
<h3 id="RC和RR的锁有什么区别？"><strong>RC和RR的锁有什么区别？</strong></h3>
<ol>
<li><strong>读已提交（RC）</strong></li>
</ol>
<p>RC保证了读已提交的数据，只看其他事务已经提交的东西，其他事务还在编辑、没提交的内容，看不到</p>
<p>RC通常使用行锁或者MVCC的方式，保证事务之间的隔离性</p>
<ol start="2">
<li><strong>可重复读（RR）</strong></li>
</ol>
<p>RR保证了第一次快照读创建的Read View会贯穿整个事务，所以多次普通 Select 读取结果是一致的，解决了不可重复读问题</p>
<h3 id="MVCC机制">MVCC机制</h3>
<h3 id="快照读和当前读">快照读和当前读</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211403697.png" alt="image-20251121140316679"></p>
<ol>
<li><strong>快照读</strong></li>
</ol>
<p>使用MVCC实现</p>
<p><strong>不加锁</strong></p>
<ol start="2">
<li><strong>当前读</strong></li>
</ol>
<p>使用临键锁（记录锁 + 间隙锁）实现</p>
<p><strong>加锁</strong></p>
<p>直接读<strong>物理行的当前版本</strong>，如果有并发写锁着它，就<strong>等待</strong>，等到对方提交并释放锁，再读最新已提交的版本</p>
<h3 id="RR隔离级别完全解决了幻读吗？"><strong>RR隔离级别完全解决了幻读吗？</strong></h3>
<blockquote>
<p>没有，比如下面这种情况：</p>
<ol>
<li>事务A使用<strong>快照读</strong>读取了3条数据</li>
<li>事务B插入ID = 100的数据并保存</li>
<li>此时事务A使用<strong>当前读</strong>就会读取到4条数据</li>
</ol>
<p>这就产生了幻读现象</p>
<ul>
<li>解决方法：在事务A的时候加间隙锁，此时事务B就不能插入数据了</li>
</ul>
</blockquote>
<h3 id="MVCC-Multi-Version-Concurrency-Control-多版本并发控制">MVCC(Multi-Version Concurrency Control)多版本并发控制</h3>
<p>可以做到读写不阻塞，且避免了类似脏读这样的问题，主要通过<strong>undo Log版本链</strong>和<strong>Read View读视图</strong>来实现。在读取数据的时候通过ReadView四个参数和Undo Log版本链中的值进行比较，判断哪一个trx_id的数据可以读取。</p>
<h3 id="Read-View读视图">Read View读视图</h3>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211405425.png" alt="image-20251121140545390"></p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211406554.png" alt="image-20251121140559582"></p>
<p>【<strong>理解</strong>】</p>
<p><img src="https://jasonqianpic.oss-cn-chengdu.aliyuncs.com/img/202511211406857.png" alt="image-20251121140628710"></p>
<p>当使用快照读的时候，会生成一个Read View，给这个Read View分配一个creator_trx_id，同时会记录下这一瞬间仍在跑的事务id列表。</p>
<p>判断一行数据能不能从redo log中看见，根据（<strong>当前行</strong>由事务Id X进行修改）</p>
<ol>
<li>如果<code>X == creator_trx_id</code>，代表是由当前事务自身进行修改的，可以查看</li>
<li>如果<code>X &lt; min_trx_id</code>，代表X事务不在活跃列表之前，已经被提交了，可以查看</li>
<li>如果<code>X ≥ max_trx_id</code>，这行来自拍照之后还未开启/未提交的事务 → 这张快照里永远不可见</li>
<li>如果<code>min ≤ X &lt; max</code>，看X事务Id是否属于m_ids，① 在 → 不可见（还没提），②不在 → 可见（已提）</li>
</ol>
<p>在可重复读（RR）隔离级别下，<strong>只会在第一次执行快照读获取一次read view</strong></p>
<p>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次执行快照读都会产生一个新的Read View副本</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）</p>
<h3 id="Read-View什么时候会消失？"><strong>Read View什么时候会消失？</strong></h3>
<ul>
<li>在读已提交（RC）隔离级别下，<strong>语句结束</strong>，Read View就消失了</li>
<li>在可重复度（RR）隔离级别下，<strong>事务结束</strong>，Read View就消失了</li>
</ul>
<h2 id="MySQL调优">MySQL调优</h2>
<h3 id="框架">框架</h3>
<p>以下内容是挡在MySQL前面的，也就是说读取数据的时候先走它们，再走MySQL</p>
<ul>
<li>读写分离</li>
<li>主从复制</li>
<li>Redis缓存</li>
<li>Java中的数据结构：在项目启动的时候，先从数据库里查询<strong>常用的数据</strong>存储到，如List，Map中，使用的时候<strong>直接获取</strong></li>
</ul>
<h3 id="硬件">硬件</h3>
<ol>
<li><strong>内存大于32g</strong></li>
</ol>
<p>MySQL存在 buffer pool ，对于数据修改，先修改内存中的数据，再将内存中的数据刷入磁盘中</p>
<p>buffer pool 占MySQL内存的 75% ~ 80% 之间</p>
<ol start="2">
<li><strong>CPU</strong></li>
</ol>
<p>MySQL的连接数（Druid连接池），最优情况下：CPU核心数 * 2 + 1（如果是固态硬盘还可以 + 1）</p>
<h3 id="SQL优化">SQL优化</h3>
<ol>
<li><strong>禁止使用 Select *</strong></li>
</ol>
<p>会读取多余字段</p>
<p>失去覆盖索引的优化机会，查询缓慢</p>
<hr>
<ol start="2">
<li><strong>共享数据</strong></li>
</ol>
<p>比如在一个业务中两个接口都<strong>同时查询一条数据</strong>，并且A接口要调用B接口，此时可以只在B接口查询，将结果通过参数传递给A</p>
<hr>
<ol start="3">
<li><strong>深分页的问题如何解决？</strong></li>
</ol>
<blockquote>
<p>什么是深分页？</p>
<p>使用如下SQL语句查询满足update_time条件的数据，跳过前100000条，取出10条数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2025-09-23 12:30:59&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time limit <span class="number">100000</span>, <span class="number">10</span>; </span><br></pre></td></tr></table></figure>
<p>由于这条SQL语句执行顺序是 from -&gt; where -&gt; select -&gt; order by -&gt; limit，在分页之前，比如满足 <strong>update_time &gt;= ‘2025-09-23 12:30:59’</strong> 的数据有80万条，此时就会触发80万次回表查询，再将查询到的结果进行limit分页，这样做很耗时间。</p>
</blockquote>
<p>【<strong>解决方法</strong>】</p>
<ul>
<li><strong>选择上 / 下一页</strong></li>
</ul>
<p>【<strong>注意</strong>】id需要为整形，并且自增的</p>
<p>前端需要将最后一条数据的id发过来，以及查询的条数就可以加快查询了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>手动选择第 N 页</strong></li>
</ul>
<p>子查询优化</p>
<p>【<strong>注意</strong>】需要一个查询条件，且有索引（update_time）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> id <span class="keyword">from</span> account o <span class="keyword">where</span> o.update_time <span class="operator">&gt;=</span> <span class="string">&#x27;2025-09-23 12:30:59&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> o.update_time limit <span class="number">100000</span>, <span class="number">10</span>) <span class="keyword">as</span> temp <span class="keyword">inner</span> <span class="keyword">join</span> account <span class="keyword">on</span> temp.id <span class="operator">=</span> account.id;</span><br></pre></td></tr></table></figure>
<p><strong>在子查询中通过二级索引查找满足条件的10条数据，不用进行回表查询</strong></p>
<p><strong>在连表查询中，通过匹配 id 获取满足条件的10条数据</strong></p>
<p><strong>此时只需要经历10次回表查询</strong></p>
<hr>
<ol start="4">
<li><strong>更新什么就改什么，而不是将全部字段update回去</strong></li>
</ol>
<p>update的时候，将一条数据所有信息查询出来放在一个对象中，只更新其中一个数据，再将整个对象update到数据库中，在高并发场景下，会造成数据不同步问题</p>
<p>比如，我第一个方法查出一条数据所有信息为a = 1，b = 1，我只修改b的值，a = 1， b = 2；这个时候另一个方法也查出这条数据的所有信息为a = 1，b = 1，此时它只修改a的值为a = 2，b = 1；第一个方法先update，将b的值改变；<br>
第二个方法再update，<strong>a的值改变</strong>，同时<strong>将b的值恢复</strong>，这就会造成数据不同步</p>
<hr>
<ol start="5">
<li><strong>日期类型选择</strong></li>
</ol>
<ul>
<li>datetime：8字节（占用大）</li>
<li>timestamp：4字节（可以显示1970-1-1到2038的时间戳，推荐）</li>
<li>data：3字节（显示时间不完全）</li>
</ul>
<hr>
<ol start="6">
<li><strong>字符类型选择</strong></li>
</ol>
<ul>
<li>数字范围很小用tinyint占1个字节，相比较于int占4个字节</li>
<li>如果确定字符数量长度，用char(1)性别、char(11)电话号码</li>
</ul>
<hr>
<h3 id="系统配置">系统配置</h3>
<ol>
<li><strong>Redo log刷盘策略</strong>，<code>innodb_flush_log_at_trx_commit</code>取值（0/1/2）</li>
</ol>
<ul>
<li>0：每隔一秒把log buffer刷到文件系统中</li>
<li>1：每次事务提交的时候，都把log buffer刷到文件系统中，立即刷新到磁盘上去</li>
<li>2：每次事务提交的时候，都把log buffer刷到系统文件中，但不会立即写入磁盘</li>
</ul>
<ol start="2">
<li><strong>bin log刷盘策略</strong>，<code>sync_binlog</code>，取值（0/1/N）</li>
</ol>
<ul>
<li>0：依赖操作系统定期同步，性能最佳，但崩溃时可能丢失多个事务</li>
<li>1：每次事务提交后同步，确保崩溃时最多丢失一个事务，安全性最高，但性能耗损最大</li>
<li>N：每提交N个事务后同步一次，平衡性能和数据安全</li>
</ul>
<hr>
<h3 id="慢SQL查询日志"><strong>慢SQL查询日志</strong></h3>
<ol>
<li>slow_query_log</li>
<li><strong>explain字段</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> orders <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>看查询语句的效率，有如下几个参数</p>
<ul>
<li>key：实际使用的索引名，如果是NULL就没有索引</li>
<li>key_len：使用索引的长度</li>
<li>rows：预计扫描的行数</li>
<li>type：访问类型</li>
</ul>
<blockquote>
<p>访问层级：<code>System &gt; Const &gt; Eq_ref &gt; Ref &gt; Range &gt; Index &gt; All</code></p>
<ol>
<li>System：表中只有一行数据，直接返回</li>
<li>const：查询命中<strong>主键</strong>或<strong>唯一索引的全部列</strong>，性能非常好，只会读取一次索引</li>
</ol>
<p>比如<code>select name from user where id = 3;</code></p>
<ol start="3">
<li>eq_ref：只会出现在<strong>多表连接</strong>（JOIN）时，而且是<strong>被驱动表</strong>（也叫第二张表、右表）用<strong>主键</strong>或<strong>唯一索引</strong>进行等值匹配，并且这些<strong>索引列都不能为 NULL</strong>。</li>
</ol>
<p>比如<code>Select * from user u join orders o on u.id = o.user_id;</code>，o.user_id是唯一索引</p>
<ol start="4">
<li>range：索引范围查找，条件是 &lt;, &gt;, between, like ‘abc%’ 等，使用索引列的范围条件（遵守最左前缀原则）</li>
</ol>
<p>比如：<code>SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-01-31';</code></p>
<ol start="5">
<li>index：扫描整个索引树，而不是表的所有行，查询只用到索引列（覆盖索引），不必回表</li>
</ol>
<p>比如：<code>select id from orders;</code>，如果id是主键，这就是index扫描</p>
<ol start="6">
<li>all：没有任何可用索引，直接从磁盘扫描</li>
</ol>
</blockquote>
<ul>
<li>Extra：额外信息</li>
</ul>
<blockquote>
<ol>
<li>Using where：查询走了索引，但是仍要在取出的数据上做一次<strong>where查询</strong></li>
</ol>
<p>使用了<strong>索引跳跃</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span> (  </span><br><span class="line">    id <span class="keyword">primary key</span>,  </span><br><span class="line">    name,  </span><br><span class="line">    age,  </span><br><span class="line">    index idx_age(age)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># age走了索引，name <span class="operator">=</span> <span class="string">&#x27;tom&#x27;</span>取出数据后过滤 —<span class="operator">&gt;</span> <span class="keyword">Using</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Using index：使用了<strong>覆盖索引</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span> (  </span><br><span class="line">    id <span class="keyword">primary key</span>,  </span><br><span class="line">    name,  </span><br><span class="line">    age,  </span><br><span class="line">    index idx_age(age)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> age, name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Using where; Using index;</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> age, name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"># 索引idx_age_name覆盖了age和name —<span class="operator">&gt;</span> <span class="keyword">Using</span> index</span><br><span class="line"># 条件age <span class="operator">&gt;</span> <span class="number">20</span>需要范围扫描，进行过滤 —<span class="operator">&gt;</span> <span class="keyword">Using</span> <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Using filesort：<strong>排序没法完全靠索引顺序完成，必须额外做排序操作</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 触发场景</span><br><span class="line"># <span class="keyword">order</span> <span class="keyword">by</span> 列没有用上索引</span><br><span class="line">index idx_age(age)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">order</span> <span class="keyword">by</span> 列不符合最左前缀原则</span><br><span class="line">index idx_name_age(name, age)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">order</span> <span class="keyword">by</span> age</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="索引-2">索引</h3>
<ol>
<li>最左前缀原则</li>
<li>索引覆盖</li>
<li>索引下推</li>
<li>主键索引尽量使用自增主键，减少页分裂</li>
</ol>
<p>因为InnoDB索引底层数据结构为B+树，它需要保证内部有序，通过主键自增的方式，让b+树增加新的数据时，<strong>永远加在最后一个叶子结点尾部</strong></p>
<ol start="5">
<li>不使用like</li>
<li><strong>版本8.0之前</strong>，在使用order by的时候，不要既使用asc，也用desc</li>
</ol>
<p>在8.0之前，索引排序方向必须一致，一旦order by混用了asc和desc，<strong>没法用B+树索引顺序</strong>，只能<strong>走filesort</strong></p>
<ol start="7">
<li>索引列不做函数运算、不计算</li>
<li>or两边其中一个没有索引就会导致全表扫描</li>
</ol>
<hr>
<p><strong>在第一个事务的update中，如果where 后面的字段没有索引，会导致第二个事务update锁表吗？</strong></p>
<p>第一个事务中：<code>update table set name = 'tmo' where id = 1;</code></p>
<p>第二个事务中：<code>update table set name = 'tmo' where id = 1;</code></p>
<p>这要分情况：</p>
<ul>
<li>如果是<strong>RC</strong>隔离级别下，<strong>不会锁表</strong>；</li>
<li>如果是<strong>RR</strong>隔离级别下，<strong>会锁表</strong></li>
</ul>
<hr>
<h2 id="零碎知识点">零碎知识点</h2>
<h3 id="内连接和外连接的区别"><strong>内连接和外连接的区别</strong></h3>
<p>内连接保留两张表拥有的数据</p>
<p>外连接分为左外连接、有外连接、全外连接，匹配不到的地方用NULL填充</p>
<h3 id="MySQL六大约束"><strong>MySQL六大约束</strong></h3>
<ol>
<li>主键约束</li>
<li>非空约束</li>
<li>唯一约束</li>
<li>默认值约束</li>
<li>外键约束</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">JasonQian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/11/21/MySQL%E5%85%AB%E8%82%A1%E6%96%87/">http://example.com/2025/11/21/MySQL%E5%85%AB%E8%82%A1%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">JasonQian's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://www.jasonqian.com/img/menhera_7.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/11/24/Redis%E5%85%AB%E8%82%A1%E6%96%87/" title="Redis八股文"><img class="cover" src="https://www.jasonqian.com/img/menhera_34.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis八股文</div></div><div class="info-2"><div class="info-item-1">Redis为什么这么快？  基于内存 io 多路复用：一个线程可以管理多个IO网络请求，内置多个API可以监听多个IO请求 单线程架构   为什么是单线程而不是多线程？  Redis是内存数据库，性能瓶颈是在内存与网络IO延迟 用单线程极大减少了多线程的上下文切换和锁的竞争    持久化机制 数据结构优化   Redis穿透&amp;击穿&amp;雪崩 穿透 当客户端请求的 key 在 缓存里找不到，而且 数据库里也没有，就会导致每次请求都绕过 Redis 直击数据库 出现的场景：  恶意/异常请求：爬虫、攻击脚本随机构造ID = 99999，但是Redis缓存中没有，导致数据库被频繁打醒 用户传参异常：用户手滑将Id = -1传入，没有击中缓存和数据库  防护措施：  布隆过滤器把所有合法 ID 的集合（或 hash）先“塞”进布隆过滤器；当请求进来先问布隆：“这个 key 可能存在吗？”  优点：大幅削减不可能存在的请求 缺点：有极小误判率，需要定期同步全量数据  缓存空值/占位符  数据库里也没有？那就把 “没有” 这个事实也缓存起来 1234// 查库后发现nullred...</div></div></div></a><a class="pagination-related" href="/2025/11/21/RocketMQ%E5%85%AB%E8%82%A1%E6%96%87/" title="RocketMQ八股文"><img class="cover" src="https://www.jasonqian.com/img/menhera_29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RocketMQ八股文</div></div><div class="info-2"><div class="info-item-1">为什么要用MQ？  应用解耦  假设有支付、订单、短信三个服务，当有一笔订单需要调用这三个服务时，需要在代码中写死这三个服务的调用接口，如果需要新增一个新的服务积分服务，又要在代码中新增调用接口，耦合度太高，不利于管理 此时引入RocketMQ，通过发布不同的topic，需要的服务只需要订阅它就可以了，这样一来，生产者不需要知道我需要调用哪些接口，只管发送消息即可。未来再需要新增服务的时候，只需要在这个服务中订阅消息就可以了。扩展性提高，维护成本降低  异步提速  假设生产者向RocketMQ中发送一条用户下单的消息需要 50ms，生产者向数据库中发送一条消息需要 50ms，支付、订单、短信三个服务接收消息后处理需要 200ms 那么用户得到反馈的时间是多少呢？ 50ms + 50ms = 100ms ，前端只需要将消息发送成功，数据库消息写入成功后就可以返回了，后端服务异步处理消息就行了，减少用户等待的时间  削峰填谷  在订单高峰期可能达到 10万/s 的qps，使用RocketMQ可以将这些消息存入消息队列中，再通过后端服务依次处理，将高峰期挤压的消息按照匀给其他时间处理，...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://www.jasonqian.com/img/menhera_1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">JasonQian</div><div class="author-info-description">1.048596</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Jason-Qian993" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">帰り道が長い</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8F%8A%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">存储引擎及架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">数据库的三大范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">关系型数据库区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">内部架构及作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">一条SQL请求的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.5.</span> <span class="toc-text">主流的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">一条查询语句的关键字执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.</span> <span class="toc-text">InnoDB的三大特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81-2"><span class="toc-number">2.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">大致介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">表级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">行级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%8F%8A%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">2.5.</span> <span class="toc-text">死锁的检测及处理策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E7%9A%84%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">3.2.</span> <span class="toc-text">个人理解的索引相关知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">为什么要有索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-number">3.5.</span> <span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E7%B4%A2%E5%BC%95%E7%89%B9%E7%82%B9"><span class="toc-number">3.6.</span> <span class="toc-text">B树索引特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%89%B9%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">B+树索引特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.</span> <span class="toc-text">B树和B+树的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">为什么用B+树而不是红黑树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.10.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88B-%E6%A0%91%E4%B8%89%E5%B1%82%E8%83%BD%E5%AD%98%E5%82%A82000%E4%B8%87%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">为什么B+树三层能存储2000万数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Innodb-MyISAM%E5%9C%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">Innodb&amp;MyISAM在存储结构的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">3.13.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-number">3.14.</span> <span class="toc-text">索引的利弊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E3%80%81%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E3%80%81%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E3%80%81%E7%B4%A2%E5%BC%95%E8%B7%B3%E8%B7%83"><span class="toc-number">3.15.</span> <span class="toc-text">回表查询、索引覆盖、索引下推、索引跳跃</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">3.16.</span> <span class="toc-text">索引失效的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">索引越多越好吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">4.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1-update-%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">执行一条 update 语句，期间发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-number">4.2.</span> <span class="toc-text">undo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">4.2.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">4.2.2.</span> <span class="toc-text">undo log版本链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-number">4.3.</span> <span class="toc-text">redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">4.3.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buffer-pool"><span class="toc-number">4.3.2.</span> <span class="toc-text">buffer pool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">4.3.3.</span> <span class="toc-text">redo log刷盘时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">4.3.4.</span> <span class="toc-text">日志文件组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">4.3.5.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log%E6%80%9D%E8%80%83"><span class="toc-number">4.3.6.</span> <span class="toc-text">redo log思考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin-log"><span class="toc-number">4.4.</span> <span class="toc-text">bin log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.4.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">三种格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bin-log%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">4.4.3.</span> <span class="toc-text">bin log刷盘时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97"><span class="toc-number">4.4.4.</span> <span class="toc-text">中继日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">4.4.5.</span> <span class="toc-text">慢查询日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BC%80%E5%90%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">事务的开启方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1ACID%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">事务ACID属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">并发事务处理带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">5.4.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RC%E5%92%8CRR%E7%9A%84%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">RC和RR的锁有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E6%9C%BA%E5%88%B6"><span class="toc-number">5.6.</span> <span class="toc-text">MVCC机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">5.7.</span> <span class="toc-text">快照读和当前读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%B9%BB%E8%AF%BB%E5%90%97%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">RR隔离级别完全解决了幻读吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-Multi-Version-Concurrency-Control-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">5.9.</span> <span class="toc-text">MVCC(Multi-Version Concurrency Control)多版本并发控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-View%E8%AF%BB%E8%A7%86%E5%9B%BE"><span class="toc-number">5.10.</span> <span class="toc-text">Read View读视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-View%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%B6%88%E5%A4%B1%EF%BC%9F"><span class="toc-number">5.11.</span> <span class="toc-text">Read View什么时候会消失？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E8%B0%83%E4%BC%98"><span class="toc-number">6.</span> <span class="toc-text">MySQL调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">6.1.</span> <span class="toc-text">框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">SQL优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">6.4.</span> <span class="toc-text">系统配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2SQL%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">6.5.</span> <span class="toc-text">慢SQL查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95-2"><span class="toc-number">6.6.</span> <span class="toc-text">索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">零碎知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">内连接和外连接的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%85%AD%E5%A4%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.2.</span> <span class="toc-text">MySQL六大约束</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/02/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/" title="Java集合八股文"><img src="https://www.jasonqian.com/img/menhera_15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java集合八股文"/></a><div class="content"><a class="title" href="/2025/12/02/Java%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/" title="Java集合八股文">Java集合八股文</a><time datetime="2025-12-01T22:36:32.000Z" title="发表于 2025-12-02 06:36:32">2025-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/24/Redis%E5%85%AB%E8%82%A1%E6%96%87/" title="Redis八股文"><img src="https://www.jasonqian.com/img/menhera_34.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis八股文"/></a><div class="content"><a class="title" href="/2025/11/24/Redis%E5%85%AB%E8%82%A1%E6%96%87/" title="Redis八股文">Redis八股文</a><time datetime="2025-11-24T00:02:58.000Z" title="发表于 2025-11-24 08:02:58">2025-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/21/MySQL%E5%85%AB%E8%82%A1%E6%96%87/" title="MySQL八股文"><img src="https://www.jasonqian.com/img/menhera_7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL八股文"/></a><div class="content"><a class="title" href="/2025/11/21/MySQL%E5%85%AB%E8%82%A1%E6%96%87/" title="MySQL八股文">MySQL八股文</a><time datetime="2025-11-20T22:08:16.000Z" title="发表于 2025-11-21 06:08:16">2025-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/21/RocketMQ%E5%85%AB%E8%82%A1%E6%96%87/" title="RocketMQ八股文"><img src="https://www.jasonqian.com/img/menhera_29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ八股文"/></a><div class="content"><a class="title" href="/2025/11/21/RocketMQ%E5%85%AB%E8%82%A1%E6%96%87/" title="RocketMQ八股文">RocketMQ八股文</a><time datetime="2025-11-20T17:45:22.000Z" title="发表于 2025-11-21 01:45:22">2025-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/20/SpringBoot%E5%85%AB%E8%82%A1%E6%96%87/" title="SpringBoot八股文"><img src="https://www.jasonqian.com/img/menhera_17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot八股文"/></a><div class="content"><a class="title" href="/2025/11/20/SpringBoot%E5%85%AB%E8%82%A1%E6%96%87/" title="SpringBoot八股文">SpringBoot八股文</a><time datetime="2025-11-20T05:34:40.000Z" title="发表于 2025-11-20 13:34:40">2025-11-20</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2022 - 2025 By JasonQian</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"></div><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="请输入搜索文字" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="http://www.beian.gov.cn/portal/recordQuery" style="margin-inline:5px" data-title="网站备案" title=""><img src="https://img.shields.io/badge/渝公网安备-50011802010611号-blue?style=flat&amp;logo=备案" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>